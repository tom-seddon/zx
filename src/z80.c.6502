;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zinit
{
ldx #zrend-zrbegin-1
.loop:stz zrbegin,X:dex:bpl loop

stz zread__ptr+0
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: X (LSB), Y (MSB) - address
; Exit: A - byte read, NZ set accordingly, X/Y preserved

MACRO LOAD_XY
lda romsel_table,Y:sta romsel
lda msb_table,Y:sta read+2
.read:lda FIX_xx00,X
ENDMACRO

; As LOAD_XY, but increments the address afterwards.
MACRO LOAD_XY_POSTINC
LOAD_XY
inx:bne nc:iny:.nc
ENDMACRO

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: X (LSB), Y (MSB) - address; A - value to write
;
; Exit: X changed, A/Y preserved
MACRO STORE_XY
stx write+1
ldx romsel_table,Y:stx romsel
ldx msb_table,Y:stx write+2
.write:sta FIX_xxxx
ENDMACRO

; As above, but preserves X. 2 cycles slower, but quicker than STX
; zp:STORE_XY:LDX zp.
MACRO STORE_XY_KEEPX
stx loadx+1
ldx romsel_table,Y:stx romsel
ldx msb_table,Y:stx write+2
.loadx:ldx #FIX_xx:.write:sta FIX_xx00,X
ENDMACRO

MACRO STORE_XY_PREDEC
dex:cpx #$ff:bne nb:dey:.nb
STORE_XY_KEEPX
ENDMACRO

MACRO STORE_XY_POSTINC
STORE_XY_KEEPX
inx:bne nc:iny:.nc
ENDMACRO

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zread
{
sei
LOAD_XY
cli
rts
}

.zwrite
{
sei
STORE_XY
cli
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry:

; zpcl,zpch - address to fetch

; Exit:

; A - byte read

; zpcl,zpch incremented

; X, Y changed

.zfetch
{

ldx zrpcl:ldy zrpch

LOAD_XY_POSTINC

stx zrpcl:sty zrpch

rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: zpcl,zpch - address to fetch

; Exit: zfetch2_lsb - first byte; A - second byte; zpcl,zpch adjusted; X, Y changed

.zfetch2
{
ldx zrpcl:ldy zrpch

LOAD_XY_POSTINC:sta zfetch2_lsb
LOAD_XY_POSTINC

stx zrpcl:sty zrpch

rts
}

; Entry zpcl,zpch - address to fetch from

; Exit: X,Y - address fetched; A changed
.zfetcha
{
ldx zrpcl:ldy zrpch

LOAD_XY_POSTINC:sta loadx+1
LOAD_XY_POSTINC

stx zrpcl:sty zrpch

tay:.loadx:ldx #FIX_xx

rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO ZBAD
jmp zbad
ENDMACRO

MACRO ZNEXT cycles
jmp znext
ENDMACRO

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include "../build/z80ops.generated.6502"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zbad
{
cli
ror a:sta zbad__opcode

jsr printstr:equs 22,128,255

jsr printfstr
equb "Invalid opcode: ",1,zbad__opcode,13
equb "AF =",2,zra,zrf," BC =",2,zrb,zrc," DE =",2,zrd,zre," HL =",2,zrh,zrl,13
equb "AF'=",2,zra2,zrf2," BC'=",2,zrb2,zrc2," DE'=",2,zrd2,zre2," HL'=",2,zrh2,zrl2,13
equb "IX=",2,zrixh,zrixl," IY=",2,zriyh,zriyl," PC=",2,zrpch,zrpcl," SP=",2,zrsph,zrspl," IR=",2,zri,zrr,13
equb 255

jsr printstrnl:equs "PC:",255:ldx zrpcl:ldy zrpch:lda #3:jsr dumpregion
jsr printstrnl:equs "Stack:",255:ldx zrspl:ldy zrsph:lda #3:jsr dumpregion
jsr printstrnl:equs "BC:",255:ldx zrc:ldy zrb:lda #2:jsr dumpregion
jsr printstrnl:equs "DE:",255:ldx zre:ldy zrd:lda #2:jsr dumpregion
jsr printstrnl:equs "HL:",255:ldx zrl:ldy zrh:lda #2:jsr dumpregion
jsr printstrnl:equs "6502 zero page:",255:ldx #0:ldy #0:lda #3:jsr dump6502

rts

.dumpregion
pha
sec
txa:sbc #1:and #(255<<dump_width_log2) AND 255:tax
tya:sbc #0:tay
pla
jmp dumpz80

}

.zrun
; Stop any funny business with ROMSEL.
sei

.znext
{
jsr zfetch

inc zrr

; Call instruction routine.
;
; NOTE: ZBAD relies on ROR A restoring the opcode!
{
asl a:tax

bcs set
.reset:jmp (zop_nonprefix_table_b7reset,X)
.set:jmp (zop_nonprefix_table_b7set,X)
}
}
