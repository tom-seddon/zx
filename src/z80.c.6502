;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zinit
{
ldx #zrend-zrbegin-1
.loop:stz zrbegin,X:dex:bpl loop

stz zread__ptr+0
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: X (LSB), Y (MSB) - address
; Exit: A - byte read, NZ set accordingly, X/Y preserved

MACRO DO_LOAD_XY
lda romsel_table,Y:sta romsel;:sta $f4
lda msb_table,Y:sta read+2
.read:lda FIX_xx00,X
ENDMACRO

MACRO DO_LOAD_XY_POSTINC
DO_LOAD_XY
inx:bne nc:iny:.nc
ENDMACRO

.load_xy
{
DO_LOAD_XY
rts
}

; As LOAD_XY, but increments the address afterwards.
.load_xy_postinc
{
DO_LOAD_XY_POSTINC
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: X (LSB), Y (MSB) - address; A - value to write
;
; Exit: X changed, A/Y preserved
.store_xy
{
stx write+1
ldx romsel_table,Y:stx romsel;:stx $f4
ldx msb_table,Y:stx write+2
.write:sta FIX_xxxx
rts
}

; As above, but preserves X. 2 cycles slower, but quicker than STX
; zp:STORE_XY:LDX zp.
MACRO DO_STORE_XY_KEEPX
stx loadx+1
ldx romsel_table,Y:stx romsel;:stx $f4
ldx msb_table,Y:stx write+2
.loadx:ldx #FIX_xx:.write:sta FIX_xx00,X
ENDMACRO

MACRO DO_STORE_XY_PREDEC
dex:cpx #$ff:bne nb:dey:.nb
DO_STORE_XY_KEEPX
ENDMACRO

.store_xy_predec
{
DO_STORE_XY_PREDEC
rts
}

.store_xy_postinc
{
DO_STORE_XY_KEEPX
inx:bne nc:iny:.nc
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zread
{
sei
DO_LOAD_XY
cli
rts
}

.zwrite
{
sei
DO_STORE_XY_KEEPX
cli
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry:

; zpcl,zpch - address to fetch

; Exit:

; A - byte read

; zpcl,zpch incremented

; X, Y changed

.zfetch
{

ldx zrpcl:ldy zrpch

DO_LOAD_XY_POSTINC

stx zrpcl:sty zrpch

rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: zpcl,zpch - address to fetch

; Exit: zfetch2_lsb - first byte; A - second byte; zpcl,zpch adjusted; X, Y changed

.zfetch2
{
ldx zrpcl:ldy zrpch

DO_LOAD_XY_POSTINC:sta zfetch2_lsb
DO_LOAD_XY_POSTINC

stx zrpcl:sty zrpch

rts
}

; Entry zpcl,zpch - address to fetch from

; Exit: X,Y - address fetched; A changed
.zfetcha
{
ldx zrpcl:ldy zrpch

DO_LOAD_XY_POSTINC:sta loadx+1
DO_LOAD_XY_POSTINC

stx zrpcl:sty zrpch

tay:.loadx:ldx #FIX_xx

rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Packs the zfXXX values into the F register.
.zpack_flags
{
lda zfhval:and #ZH_MASK:sta zrf

lda zf53val:and #%00101000
bit zfcval:bpl noc:ora #ZC_MASK:.noc
bit zfnval:bpl non:ora #ZN_MASK:.non
ldx zfszval:ora sz_flag_values,X
ldx zfpval:ora p_flag_values,X
ora zrf:sta zrf
rts
}

; Unpacks the F register into the zfXXX values.
.zunpack_flags
{
ldx zrf
lda fszvals,X:sta zfszval
lda fpvals,X:sta zfpval
lda fcvals,X:sta zfcval
lda fnvals,X:sta zfnval
stx zfhval
stx zf53val
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO ZBAD
jmp zbad
ENDMACRO

MACRO ZNEXT cycles
jmp znext
ENDMACRO

MACRO ZTSTATES n
ENDMACRO

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO DO_PUSH_PC
ldx zrspl:ldy zrsph
lda zrpch:DO_STORE_XY_PREDEC
lda zrpcl:DO_STORE_XY_PREDEC
stx zrspl:sty zrsph
ENDMACRO

.zpush_pc
{
DO_PUSH_PC
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Changes: A, X. Preserves: Y.
.zdo_inc
{
sta zop__tmp:inc a:tax:eor zop__tmp:sta zfhval:txa
sta zfszval
sta zf53val
stz zfnval
cmp #$80:beq setv
.resetv:ldx #ZP0_VALUE:stx zfpval:rts
.setv:ldx #ZP1_VALUE:stx zfpval:rts
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Changes: A, X. Preserves: Y.
.zdo_dec
{
sta zop__tmp:dec a:tax:eor #$ff:eor zop__tmp:sta zfhval:txa
sta zfszval
sta zf53val
ldx #$80:stx zfnval
cmp #$7f:beq setv
.resetv:ldx #ZP0_VALUE:stx zfpval:rts
.setv:ldx #ZP1_VALUE:stx zfpval:rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO DO_ZADD
sta zop__tmp			    ; zop__tmp=operand B
lda zra:tax:adc zop__tmp:sta zra    ; zra=result
sta zfszval			    ; Set/reset S+Z
sta zf53val			    ; Set/reset 5+3
ror zfcval			    ; Set/reset C
txa:eor zop__tmp:eor zra:sta zfhval ; Set/reset H
stz zfnval			    ; Reset N
ldy #ZP0_VALUE:bvc nv:ldy #ZP1_VALUE:.nv:sty zfpval ; Set/reset P
ENDMACRO

.zop_adc
{
asl zfcval
DO_ZADD
ZNEXT 0
}

.zop_add
{
clc
DO_ZADD
ZNEXT 0
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO DO_ZADD16_OR_ADC16 dl,dh,sl,sh,is_adc
IF is_adc:asl zfcval:ELSE:clc:ENDIF

lda dl:adc sl:sta dl

IF dh==sh
lda dh:tax:adc sh:sta dh
IF is_adc:bmi store:ora dl:beq store:lda #1:.store:sta zfszval:ENDIF
txa:eor sh:eor dh:sta zfhval	; Set/reset H
ELSE
lda sh:sta zop__tmp
lda dh:tax:adc sh:sta dh
IF is_adc:bmi store:ora dl:beq store:lda #1:.store:sta zfszval:ENDIF
txa:eor zop__tmp:eor dh:sta zfhval ; Set/reset H
ENDIF

stz zfnval			; Reset N
ror zfcval			; Set/reset C
ENDMACRO



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO DO_ZSUB_OR_CP is_sub
lda zra:tax:sbc zop__tmp
IF is_sub:sta zra:ENDIF
sta zfszval			; Set/reset S+Z

 ; CP sets bits 5+3 from the operand.
IF is_sub:sta zf53val:ELSE:ldy zop__tmp:sty zf53val:ENDIF

eor #$80:ror a					    ; Set/reset C
txa:eor zop__tmp:eor zra:sta zfhval		    ; Set/reset H
lda #128:sta zfnval				    ; Set N
ldy #ZP0_VALUE:bvc nv:ldy #ZP1_VALUE:.nv:sty zfpval ; Set/reset P
ENDMACRO

.zop_sub
{
sec
sta zop__tmp			    ; zsub__tmp=operand B
DO_ZSUB_OR_CP 1
ZNEXT 0
}

.zop_sbc
{
sta zop__tmp
lda zfcval:eor #$80:asl a
DO_ZSUB_OR_CP 1
ZNEXT 0
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_cp
{
sec
sta zop__tmp
DO_ZSUB_OR_CP 0
ZNEXT 0
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_and
{
; SZ5H3PNC
; SZ513P00
and zra:sta zra
sta zf53val			; Set bits 5+3
sta zfszval			; Set/reset S+Z
sta zfpval			; Set/reset P
lda #ZH_MASK:sta zfhval		; Set H
stz zfnval			; Reset N
stz zfhval			; Reset H
stz zfcval			; Reset C
ZNEXT 0
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; SZ5H3PNC
; SZ503P00
.zop_or
{
ora zra:sta zra
sta zf53val			; Set bits 5+3
sta zfszval			; Set/reset S+Z
sta zfpval			; Set/reset P
stz zfhval			; Reset H
stz zfnval			; Reset N
stz zfhval			; Reset H
stz zfcval			; Reset C
ZNEXT 0
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_xor
{
eor zra:sta zra
sta zf53val			; Set bits 5+3
sta zfszval			; Set/reset S+Z
sta zfpval			; Set/reset P
stz zfhval			; Reset H
stz zfnval			; Reset N
stz zfhval			; Reset H
stz zfcval			; Reset C
ZNEXT 0
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The shifts/rotates operate on 6502 accumulator, preserving X and Y.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_rlc
{
cmp #$80:rol a
ror zfcval			; C set from old bit 7
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_rrc
{
sta zop__tmp:lsr a:lda zop__tmp:ror a
ror zfcval			; C set from old bit 0
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_rl
{
asl zfcval:rol a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_rr
{
asl zfcval:ror a
ror zfcval			; C set from old bit 0
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_sla
{
asl a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_sra
{
cmp #$80:ror a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_sll
{
sec:rol a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_srl
{
lsr a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_bit
{
; SZ5H3VNC
; *Z513*0-
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
ldy #ZP0_VALUE:tax:beq pv_done:ldy #ZP1_VALUE:.pv_done ; PV set same as Z
lda #$10:sta zfhval		; H set
stz zfnval			; N reset
; C unalterened
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_daa
{
; http://www.worldofspectrum.org/faq/reference/z80reference.htm#DAA

lda #0				; adjustment
tay				; carry flag

; Select adjustment value upper nybble.
{
ldx zra:cpx #$9a:bcs adjust_6x
ldx zfcval:bpl done
.adjust_6x:ora #$60		; adjustment value is $6x
dey				; set carry
.done
}

; Select adjustment value lower nybble.
{
tax:lda zra:and #$0f:cmp #10:bcs adjust_x6
lda zfhval:and #$10:beq done
.adjust_x6:txa:ora #$06:tax	; adjustment value is $x6
.done:txa
}

; Set Z80 carry flag.
sty zfcval

; Get original accumulator for later.
ldy zra

; Adjust accumulator.
{
ldx zfnval:bmi sub
.add:clc:adc zra:sta zra:bra adjusted
.sub:sta zop__tmp:sec:tya:sbc zop__tmp:sta zra
.adjusted
}

; Set flags.
{
sta zf53val			; 5/3 set from result.
sta zfszval			; S/Z set from result.
sta zfpval			; P set from result.
; N unaffected.
; C already set above.
tya:eor zra:sta zfhval		; H set from operation.
}

; And that's it.
ZNEXT 4
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_di
{
stz ziff1:stz ziff2

ZNEXT 4
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_ei
{
lda #1:sta ziff1:sta ziff2

ZNEXT 4
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_rst
{
lsr a:and #%00111000:sta zop__tmp

jsr zpush_pc

lda zop__tmp:sta zrpcl:stz zrpch

ZNEXT 11
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Gets effective address for (IX+d) or (IY+d).

; Entry: i[xy]l,i[xy]h - IX value; zdisplacement - 8-bit displacement

; Exit: X (LSB), Y (MSB) - effective address

MACRO DO_GET_INDEX_DISPLACED l,h
clc:lda l:adc zdisplacement:tax
ldy h:bcc nc:iny:.nc
ENDMACRO

.zget_ix_displaced
{
DO_GET_INDEX_DISPLACED zrixl,zrixh
rts
}

.zget_iy_displaced
{
DO_GET_INDEX_DISPLACED zriyl,zriyh
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.ops_start
include "../build/z80ops.generated.6502"
.ops_end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zbad
{
cli
ror a:sta zbad__opcode
jsr zpack_flags

jsr printstr:equs 22,128,255

jsr printfstr
equb "Invalid opcode: ",1,zbad__opcode,13
equb "AF =",2,zra,zrf," BC =",2,zrb,zrc," DE =",2,zrd,zre," HL =",2,zrh,zrl,"  IX=",2,zrixh,zrixl,"  PC=",2,zrpch,zrpcl,"  I=",1,zri,13
equb "AF'=",2,zra2,zrf2," BC'=",2,zrb2,zrc2," DE'=",2,zrd2,zre2," HL'=",2,zrh2,zrl2,"  IY=",2,zriyh,zriyl,"  SP=",2,zrsph,zrspl,"  R=",1,zrr,13
equb 255

jsr printstrnl:equs "PC:",255:ldx zrpcl:ldy zrpch:lda #3:jsr dumpregion
jsr printstrnl:equs "Stack:",255:ldx zrspl:ldy zrsph:lda #3:jsr dumpregion
jsr printstrnl:equs "BC:",255:ldx zrc:ldy zrb:lda #2:jsr dumpregion
jsr printstrnl:equs "DE:",255:ldx zre:ldy zrd:lda #2:jsr dumpregion
jsr printstrnl:equs "HL:",255:ldx zrl:ldy zrh:lda #2:jsr dumpregion
jsr printstrnl:equs "6502 zero page:",255:ldx #0:ldy #0:lda #3:jsr dump6502

rts

.dumpregion
pha
sec
txa:sbc #1:and #(255<<dump_width_log2) AND 255:tax
tya:sbc #0:tay
pla
jmp dumpz80

}

.zrun
; Stop any funny business with ROMSEL.
sei

.znext
{
jsr zfetch

inc zrr

; Call instruction routine.
;
; NOTE: ZBAD relies on ROR A restoring the opcode!
{
asl a:tax

bcs set
.reset:jmp (zop_table_0xxxxxxx,X)
.set:jmp (zop_table_1xxxxxxx,X)
}
}

.zprefixddcb
{
jsr zfetch:sta zdisplacement
jsr zfetch

inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_DDCB_0xxxxxxx,X)
.b7set:jmp (zop_table_DDCB_1xxxxxxx,X)
}

.zprefixfdcb
{
jsr zfetch:sta zdisplacement
jsr zfetch

inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_FDCB_0xxxxxxx,X)
.b7set:jmp (zop_table_FDCB_1xxxxxxx,X)
}

.zprefixdd
{
jsr zfetch;:sta zprefixed_instruction

inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_DD_0xxxxxxx,X)
.b7set:jmp (zop_table_DD_1xxxxxxx,X)
}

.zprefixfd
{
jsr zfetch:inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_FD_0xxxxxxx,X)
.b7set:jmp (zop_table_DD_1xxxxxxx,X)
}

.zprefixcb
{
jsr zfetch:inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_CB_0xxxxxxx,X)
.b7set:jmp (zop_table_CB_1xxxxxxx,X)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
