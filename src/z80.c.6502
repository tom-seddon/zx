;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zinit
{
ldx #zrend-zrbegin-1
.loop:stz zrbegin,X:dex:bpl loop

stz zread__ptr+0
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: X (LSB), Y (MSB) - address
; Exit: A - byte read, NZ set accordingly, X/Y preserved

MACRO DO_LOAD_XY
lda romsel_read_table,Y:sta romsel;:sta $f4
lda msb_table,Y:sta read+2
.read:lda FIX_xx00,X
ENDMACRO

MACRO DO_LOAD_XY_POSTINC
DO_LOAD_XY
inx:bne nc:iny:.nc
ENDMACRO

.load_xy
{
DO_LOAD_XY
rts
}

; As LOAD_XY, but increments the address afterwards.
.load_xy_postinc
{
DO_LOAD_XY_POSTINC
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: X (LSB), Y (MSB) - address; A - value to write
;
; Exit: X changed, A/Y preserved
.store_xy
{
stx write+1
ldx romsel_write_table,Y:stx romsel;:stx $f4
ldx msb_table,Y:stx write+2
.write:sta FIX_xxxx
.done
rts
}

; As above, but preserves X. 2 cycles slower, but quicker than STX
; zp:STORE_XY:LDX zp.
MACRO DO_STORE_XY_KEEPX
stx loadx+1
ldx romsel_write_table,Y:stx romsel;:stx $f4
ldx msb_table,Y:stx write+2
.loadx:ldx #FIX_xx:.write:sta FIX_xx00,X
.done
ENDMACRO

MACRO DO_STORE_XY_PREDEC
dex:cpx #$ff:bne nb:dey:.nb
DO_STORE_XY_KEEPX
ENDMACRO

.store_xy_predec
{
DO_STORE_XY_PREDEC
rts
}

.store_xy_postinc
{
DO_STORE_XY_KEEPX
inx:bne nc:iny:.nc
rts
}

.zwrite
{
sei
DO_STORE_XY_KEEPX
cli
rts
}

IF P%>&3000:ERROR "write routines overlap shadow RAM":ENDIF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zread
{
sei
DO_LOAD_XY
cli
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry:

; zpcl,zpch - address to fetch

; Exit:

; A - byte read

; zpcl,zpch incremented

; X, Y changed

.zfetch
{

ldx zrpcl:ldy zrpch

DO_LOAD_XY_POSTINC

stx zrpcl:sty zrpch

rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: zpcl,zpch - address to fetch

; Exit: zfetch2_lsb - first byte; A - second byte; zpcl,zpch adjusted; X, Y changed

.zfetch2
{
ldx zrpcl:ldy zrpch

DO_LOAD_XY_POSTINC:sta zfetch2_lsb
DO_LOAD_XY_POSTINC

stx zrpcl:sty zrpch

rts
}

; Entry zpcl,zpch - address to fetch from

; Exit: X,Y - address fetched; A changed
.zfetcha
{
ldx zrpcl:ldy zrpch

DO_LOAD_XY_POSTINC:sta loadx+1
DO_LOAD_XY_POSTINC

stx zrpcl:sty zrpch

tay:.loadx:ldx #FIX_xx

rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Packs the zfXXX values into the F register.
.zpack_flags
{
lda zfhval:and #ZH_MASK:sta zrf

lda zf53val:and #%00101000
bit zfcval:bpl noc:ora #ZC_MASK:.noc
bit zfnval:bpl non:ora #ZN_MASK:.non
ldx zfszval:ora sz_flag_values,X
ldx zfpval:ora p_flag_values,X
ora zrf:sta zrf
rts
}

; Unpacks the F register into the zfXXX values.
.zunpack_flags
{
ldx zrf
lda fszvals,X:sta zfszval
lda fpvals,X:sta zfpval
lda fcvals,X:sta zfcval
lda fnvals,X:sta zfnval
stx zfhval
stx zf53val
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO ZBAD
jmp zbad
ENDMACRO

MACRO ZNEXT cycles
jmp znext
ENDMACRO

MACRO ZTSTATES n
ENDMACRO

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zpush_pc
{
ldx zrspl:ldy zrsph
lda zrpch:DO_STORE_XY_PREDEC
lda zrpcl:DO_STORE_XY_PREDEC
stx zrspl:sty zrsph
rts
}

.zpop_pc
{
ldx zrspl:ldy zrsph
DO_LOAD_XY_POSTINC:sta zrpcl
DO_LOAD_XY_POSTINC:sta zrpch
stx zrspl:sty zrsph
rts
}

; Adds A (signed) to PC.
.zdisplace_pc
{
clc:and #255:bmi backwards
.forwards:adc zrpcl:sta zrpcl:bcc fnc:inc zrpch:.fnc:rts
.backwards:adc zrpcl:sta zrpcl:bcs bnb:dec zrpch:.bnb:rts

; backwards case is:
;
; clc
; lda l:adc d:sta l    - 2s complement addition
; lda h:adc #$ff:sta h - add sign-extended high byte
;
; so, if C is set after first addition, H will be unaffected...
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Changes: A, X. Preserves: Y.
.zdo_inc
{
sta zop__tmp:inc a:tax:eor zop__tmp:sta zfhval:txa
sta zfszval
sta zf53val
stz zfnval
cmp #$80:beq setv
.resetv:ldx #ZP0_VALUE:stx zfpval:rts
.setv:ldx #ZP1_VALUE:stx zfpval:rts
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Changes: A, X. Preserves: Y.
.zdo_dec
{
sta zop__tmp:dec a:tax:eor #$ff:eor zop__tmp:sta zfhval:txa
sta zfszval
sta zf53val
ldx #$80:stx zfnval
cmp #$7f:beq setv
.resetv:ldx #ZP0_VALUE:stx zfpval:rts
.setv:ldx #ZP1_VALUE:stx zfpval:rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MACRO DO_ZADD16_OR_ADC16 dl,dh,sl,sh,is_adc
; IF is_adc:asl zfcval:ELSE:clc:ENDIF

; lda dl:adc sl:sta dl

; IF dh==sh
; lda dh:tax:adc sh:sta dh
; IF is_adc:bmi store:ora dl:beq store:lda #1:.store:sta zfszval:ENDIF
; txa:eor sh:eor dh:sta zfhval	; Set/reset H
; ELSE

; lda sh:sta zop__tmp
; lda dh:tax:adc sh:sta dh
; IF is_adc:bmi store:ora dl:beq store:lda #1:.store:sta zfszval:ENDIF
; txa:eor zop__tmp:eor dh:sta zfhval ; Set/reset H

; ENDIF

; stz zfnval			; Reset N
; ror zfcval			; Set/reset C
; ENDMACRO

; X=ZP address of LSB of dest; Y=ZP address of LSB of source
.do_zadd16
{
clc
lda $00,X			; A = LhsL
adc $0000,Y			; A = ResL
sta $00,X			; A = ResL

lda $0001,Y			; A = RhsH
sta zop__tmp			; zop__tmp = RhsH
adc $01,X			; A = ResH
tay				; Y = ResH
eor $01,X			; A = ResH ^ LhsH
eor zop__tmp			; A = RenH ^ LhsH ^ RhsH
sta zfhval			; H from result
sty $01,X			; store result
sty zf53val			; 5/3 from result
stz zfnval			; N=0
ror zfcval			; C from result
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; adc hl,r

; X=ZP address of LSB of source

.do_zadc16_hl
{

; HL = HL + Rhs

asl zfcval
lda zrl				; A = L
adc $00,X			; A = ResL
sta zrl				; A = ResL
; 
lda zrh				; A = H
adc $01,X			; A = ResH
tay				; Y = ResH
eor $01,X			; A = ResH ^ RhsH
eor zrh				; A = ResH ^ RhsH ^ LhsH
sta zfhval			; H from result
sty zrh				; store result

sty zf53val			; 5/3 from result
stz zfnval			; N=0
ror zfcval			; C from result

tya:bmi storesz:ora zrl:beq storesz:lda #1:.storesz:sta zfszval ; S/Z from result

bvs setp			; P from result
.resetp:lda #ZP0_VALUE:sta zfpval:rts 
.setp:lda #ZP1_VALUE:sta zfpval:rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; sbc hl,r

; X=ZP address of LSB of source

.do_zsbc16_hl
{

; HL = HL - Rhs - C

lda zfcval:eor #$80:asl a

lda zrl
sbc $00,X
sta zrl

lda zrh				; A = H
sbc $01,X			; A = ResH
tay				; X = ResH
eor $01,X			; A = ResH ^ RhsH
eor zrh				; A = ResH ^ RhsH ^ LhsH
sta zfhval			; H from result
sty zrh				; store result
sty zf53val			; 5/3 from result
lda #$80:sta zfnval		; N=1

ror a:eor #$80:sta zfcval	; C from result

tya:bmi storesz:ora zrl:beq storesz:lda #1:.storesz:sta zfszval ; S/Z from result

bvs setp			; P from result
.resetp:lda #ZP0_VALUE:sta zfpval:rts 
.setp:lda #ZP1_VALUE:sta zfpval:rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO DO_ZADD
sta zop__tmp			    ; zop__tmp=operand B
lda zra:tax:adc zop__tmp:sta zra    ; zra=result
sta zfszval			    ; Set/reset S+Z
sta zf53val			    ; Set/reset 5+3
ror zfcval			    ; Set/reset C
txa:eor zop__tmp:eor zra:sta zfhval ; Set/reset H
stz zfnval			    ; Reset N
ldy #ZP0_VALUE:bvc nv:ldy #ZP1_VALUE:.nv:sty zfpval ; Set/reset P
ENDMACRO

.zdo_adc
{
asl zfcval
DO_ZADD
rts
}

.zdo_add
{
clc
DO_ZADD
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO DO_ZSUB_OR_CP_THEN_RTS is_sub

; Res = Lhs [Acc] - Rhs [zop__tmp]

lda zra				; A = Lhs
tax				; X = Lhs
sbc zop__tmp			; A = Res

; SUB/SBC store the result to the accumulator
IF is_sub:sta zra:ENDIF

sta zfszval			; S/Z from result

; CP sets bits 5+3 from operand; SUB/SBC, from result.
IF is_sub:sta zf53val:ELSE:lda zop__tmp:sta zf53val:ENDIF ; 5/3 as appropriate

ror a:eor #$80:sta zfcval	; C from result

txa				; A = Lhs
eor zop__tmp			; A = Lhs ^ Rhs
eor zfszval			; A = Lhs ^ Rhs ^ Res
sta zfhval			; H from result

lda #128:sta zfnval		; Set N

bvs setv			; P from result
.resetv:ldy #ZP0_VALUE:sty zfpval:rts
.setv:ldy #ZP1_VALUE:sty zfpval:rts
ENDMACRO

.zdo_sub
{
sec
sta zop__tmp			    ; zsub__tmp=operand B
DO_ZSUB_OR_CP_THEN_RTS 1
}

.zdo_sbc
{
sta zop__tmp
lda zfcval:eor #$80:asl a
DO_ZSUB_OR_CP_THEN_RTS 1
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_cp
{
sec
sta zop__tmp
DO_ZSUB_OR_CP_THEN_RTS 0
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_and
{
; SZ5H3PNC
; SZ513P00
and zra:sta zra
sta zf53val			; Set bits 5+3
sta zfszval			; Set/reset S+Z
sta zfpval			; Set/reset P
lda #ZH_MASK:sta zfhval		; Set H
stz zfnval			; Reset N
stz zfhval			; Reset H
stz zfcval			; Reset C
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; SZ5H3PNC
; SZ503P00
.zdo_or
{
ora zra:sta zra
sta zf53val			; Set bits 5+3
sta zfszval			; Set/reset S+Z
sta zfpval			; Set/reset P
stz zfhval			; Reset H
stz zfnval			; Reset N
stz zfhval			; Reset H
stz zfcval			; Reset C
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_xor
{
eor zra:sta zra
sta zf53val			; Set bits 5+3
sta zfszval			; Set/reset S+Z
sta zfpval			; Set/reset P
stz zfhval			; Reset H
stz zfnval			; Reset N
stz zfhval			; Reset H
stz zfcval			; Reset C
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The shifts/rotates operate on 6502 accumulator, preserving X and Y.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_rlc
{
cmp #$80:rol a
ror zfcval			; C set from old bit 7
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_rrc
{
sta zop__tmp:lsr a:lda zop__tmp:ror a
ror zfcval			; C set from old bit 0
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_rl
{
asl zfcval:rol a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_rr
{
asl zfcval:ror a
ror zfcval			; C set from old bit 0
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_sla
{
asl a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_sra
{
cmp #$80:ror a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_sll
{
sec:rol a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_srl
{
lsr a
ror zfcval			; C set from old bit 7
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
stz zfhval			; H reset
sta zfpval			; P set from result
stz zfnval			; N reset
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zdo_bit
{
; SZ5H3VNC
; *Z513*0-
sta zfszval			; S/Z set from result
sta zf53val			; 5/3 set from result
ldy #ZP0_VALUE:tax:beq pv_done:ldy #ZP1_VALUE:.pv_done ; PV set same as Z
lda #$10:sta zfhval		; H set
stz zfnval			; N reset
; C unalterened
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Entry: X (LSB), Y (MSB) = port

; Exit: A = byte read
.zdo_in
{
jsr call_handler

sta zfszval			; N/Z set from result
sta zf53val			; 5/3 set from result
sta zfpval			; P from result
stz zfhval			; H=0
stz zfnval			; N=0
; C unchanged

rts

.call_handler:jmp (zin_handler)
}

; Entry: X (LSB), Y (MSB) - port; A - byte to write
.zdo_out
{
jsr call_handler
rts

.call_handler:jmp (zout_handler)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_daa
{
; http://www.worldofspectrum.org/faq/reference/z80reference.htm#DAA

lda #0				; adjustment
tay				; carry flag

; Select adjustment value upper nybble.
{
ldx zra:cpx #$9a:bcs adjust_6x
ldx zfcval:bpl done
.adjust_6x:ora #$60		; adjustment value is $6x
dey				; set carry
.done
}

; Select adjustment value lower nybble.
{
tax:lda zra:and #$0f:cmp #10:bcs adjust_x6
lda zfhval:and #$10:beq done
.adjust_x6:txa:ora #$06:tax	; adjustment value is $x6
.done:txa
}

; Set Z80 carry flag.
sty zfcval

; Get original accumulator for later.
ldy zra

; Adjust accumulator.
{
ldx zfnval:bmi sub
.add:clc:adc zra:sta zra:bra adjusted
.sub:sta zop__tmp:sec:tya:sbc zop__tmp:sta zra
.adjusted
}

; Set flags.
{
sta zf53val			; 5/3 set from result.
sta zfszval			; S/Z set from result.
sta zfpval			; P set from result.
; N unaffected.
; C already set above.
tya:eor zra:sta zfhval		; H set from operation.
}

; And that's it.
ZNEXT 4
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_di
{
stz ziff1:stz ziff2

ZNEXT 4
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_ei
{
lda #1:sta ziff1:sta ziff2

ZNEXT 4
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_rst
{
lsr a:and #%00111000:sta zop__tmp

jsr zpush_pc

lda zop__tmp:sta zrpcl:stz zrpch

ZNEXT 11
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_halt
{
jmp zbad
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_neg
{

; A = 0 - A

sec
lda #0:sbc zra:sta zra

lda zfszval			; S/Z from result
sta zf53val			; 5/3 from result
txa:eor zra:sta zfhval		; H from result
lda #$80:sta zfnval		; N=1
cpx #1:ror zfcval		; C from result
cpx #$80:beq setv		; P from result
.resetv:lda #ZP0_VALUE:sta zfpval:ZNEXT 8
.setv:lda #ZP1_VALUE:sta zfpval:ZNEXT 8
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_retn
{
jsr zpop_pc
lda ziff2:sta ziff1
ZNEXT 14
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_reti
; Fall through to RET...
.zop_ret
{
jsr zpop_pc
ZNEXT 10
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_im
{
; extract bits 3 and 4 of opcode
lsr a				; get opcode
lsr a:lsr a:lsr a		; shift bits 3,4 down
and #%00000011			; get bits 3,4
sta zinterrupt_mode
ZNEXT 8
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zop_ld_i_a
{
lda zra:sta zri
ZNEXT 9
}

.zop_ld_r_a
{
lda zra:sta zrr:sta zrr_bit7
rts
}

.zop_ld_a_i
{
lda zri:sta zra
jmp finish_special_ld
}

.zop_ld_a_r
{
lda zrr:and #%0111111			  ; get bits 0-6
bit zrr_bit7:bpl done:ora #%10000000:.done ; fix up bit 7
jmp finish_special_ld
}

.zop_rrd
{

; acc      mem         acc      mem
; AAAAaaaa MMMMmmmm -> AAAAmmmm aaaaMMMM

ldx zrl:ldy zrh:jsr load_xy	; MMMMmmmm
sta zop__tmp			; MMMMmmmm

lsr a:lsr a:lsr a:lsr a		; 0000MMMM
sta zindex__tmp+0		; 0000MMMM
lda zra				; AAAAaaaa
asl a:asl a:asl a:asl a		; aaaa0000
ora zindex__tmp+0		; aaaaMMMM
jsr store_xy

lda zra:and #%11110000:sta zra	; AAAA0000
lda zop__tmp:and #%00001111	; 0000mmmm
ora zra:sta zra			; AAAAmmmm

sta zfszval			; S+Z from result
sta zf53val			; 5+3 from result
stz zfhval			; H=0
sta zfpval			; P from result
stz zfnval			; N reset
; C unchanged

ZNEXT 18
}

.zop_rld
{

; mem      acc         mem      acc
; AAAAaaaa MMMMmmmm -> AAAAMMMM mmmmaaaa

ldx zrl:ldy zrh:jsr load_xy	; MMMMmmmm
sta zop__tmp			; MMMMmmmm

lsr a:lsr a:lsr a:lsr a		; 0000MMMM
sta zindex__tmp+0		; 0000MMMM
lda zra:and #%11110000		; AAAA0000
ora zindex__tmp+0		; AAAAMMMM
jsr store_xy

lda zop__tmp			; MMMMmmmm
asl a:asl a:asl a:asl a		; mmmm0000
sta zop__tmp			; mmmm0000
lda zra:and #%00001111		; 0000aaaa
ora zop__tmp			; mmmmaaaa
sta zra

sta zfszval			; S+Z from result
sta zf53val			; 5+3 from result
stz zfhval			; H=0
sta zfpval			; P from result
stz zfnval			; N reset
; C unchanged

ZNEXT 18

}

.finish_special_ld
{
sta zfszval			; S+Z from result
sta zf53val			; 5/3 from result
stz zfhval			; H=0
stz zfnval			; N=0
; C unchanged
lda ziff2:bne setp
.resetp:lda #ZP0_VALUE:sta zfpval:ZNEXT 9
.setp:lda #ZP1_VALUE:sta zfpval:ZNEXT 9
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Gets effective address for (IX+d) or (IY+d).

; Entry: i[xy]l,i[xy]h - IX value; zdisplacement - 8-bit displacement

; Exit: X (LSB), Y (MSB) - effective address

MACRO DO_GET_INDEX_DISPLACED l,h
clc:lda l:adc zdisplacement:tax
ldy h:bcc nc:iny:.nc
ENDMACRO

.zget_ix_displaced
{
DO_GET_INDEX_DISPLACED zrixl,zrixh
rts
}

.zget_iy_displaced
{
DO_GET_INDEX_DISPLACED zriyl,zriyh
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.ops_start
include "../build/z80ops.generated.6502"
.ops_end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zbad
{
cli
ror a:sta zbad__opcode
jsr zpack_flags

jsr printstr:equs 22,128,255

jsr printfstr
equb "Invalid opcode: ",1,zbad__opcode,13
equb "AF =",2,zra,zrf," BC =",2,zrb,zrc," DE =",2,zrd,zre," HL =",2,zrh,zrl,"  IX=",2,zrixh,zrixl,"  PC=",2,zrpch,zrpcl,"  I=",1,zri,13
equb "AF'=",2,zra2,zrf2," BC'=",2,zrb2,zrc2," DE'=",2,zrd2,zre2," HL'=",2,zrh2,zrl2,"  IY=",2,zriyh,zriyl,"  SP=",2,zrsph,zrspl,"  R=",1,zrr,13
equb 255

jsr printstrnl:equs "PC:",255:ldx zrpcl:ldy zrpch:lda #3:jsr dumpregion
jsr printstrnl:equs "Stack:",255:ldx zrspl:ldy zrsph:lda #3:jsr dumpregion
jsr printstrnl:equs "BC:",255:ldx zrc:ldy zrb:lda #2:jsr dumpregion
jsr printstrnl:equs "DE:",255:ldx zre:ldy zrd:lda #2:jsr dumpregion
jsr printstrnl:equs "HL:",255:ldx zrl:ldy zrh:lda #2:jsr dumpregion
jsr printstrnl:equs "6502 zero page:",255:ldx #0:ldy #0:lda #3:jsr dump6502

lda #$80:sta zaborted

rts

.dumpregion
pha
sec
txa:sbc #1:and #(255<<dump_width_log2) AND 255:tax
tya:sbc #0:tay
pla
jmp dumpz80

}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zrun_done
cli
rts

.zrun
; Stop any funny business with ROMSEL.
sei

; Don't check the quit flag straight away!
jmp znext2

.znext

bit zquit:bmi zrun_done

.znext2
{
jsr zfetch
inc zrr

; Call instruction routine.
;
; NOTE: ZBAD relies on ROR A restoring the opcode!
{
asl a:tax

bcs set
.reset:jmp (zop_table_0xxxxxxx,X)
.set:jmp (zop_table_1xxxxxxx,X)
}
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zprefixddcb
{
jsr zfetch:sta zdisplacement
jsr zfetch

inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_DDCB_0xxxxxxx,X)
.b7set:jmp (zop_table_DDCB_1xxxxxxx,X)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zprefixfdcb
{
jsr zfetch:sta zdisplacement
jsr zfetch

inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_FDCB_0xxxxxxx,X)
.b7set:jmp (zop_table_FDCB_1xxxxxxx,X)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zprefixdd
{
jsr zfetch;:sta zprefixed_instruction

inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_DD_0xxxxxxx,X)
.b7set:jmp (zop_table_DD_1xxxxxxx,X)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zprefixfd
{
jsr zfetch:inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_FD_0xxxxxxx,X)
.b7set:jmp (zop_table_DD_1xxxxxxx,X)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zprefixcb
{
jsr zfetch:inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_CB_0xxxxxxx,X)
.b7set:jmp (zop_table_CB_1xxxxxxx,X)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zprefixed
{
jsr zfetch:inc zrr

asl a:tax:bcs b7set
.b7reset:jmp (zop_table_ED_0xxxxxxx,X)
.b7set:jmp (zop_table_ED_1xxxxxxx,X)
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zhandle_in_default
{
lda #255
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.zhandle_out_default
{
rts
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
